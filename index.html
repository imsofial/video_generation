<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>ConferenceHall Panorama Tour</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #000;
      }
      #loading {
        position: fixed;
        top: 10px;
        left: 10px;
        padding: 6px 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        font-family: system-ui, sans-serif;
        font-size: 12px;
        border-radius: 4px;
        z-index: 10;
      }
      #debug {
        position: fixed;
        bottom: 10px;
        left: 10px;
        padding: 6px 10px;
        background: rgba(0, 0, 0, 0.5);
        color: #0f0;
        font-family: system-ui, sans-serif;
        font-size: 11px;
        border-radius: 4px;
        z-index: 10;
        max-width: 60%;
        white-space: pre-wrap;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
          "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js"
        }
      }
    </script>
  </head>

  <body>
    <div id="loading">Loading splat & path...</div>
    <div id="debug"></div>

    <script type="module">
      import * as THREE from "three";
      import { SplatMesh } from "@sparkjsdev/spark";

      const loadingEl = document.getElementById("loading");
      const debugEl = document.getElementById("debug");
      function setDebug(text) { debugEl.textContent = text; }

      // ---------- THREE setup ----------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      const fov = 70, near = 0.01, far = 1000;
      const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, near, far);
      const renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setPixelRatio(window.devicePixelRatio * 0.75);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // ---------- load PLY ----------
      const splat = new SplatMesh({ url: "raw_data/ConferenceHall.ply" });
      scene.add(splat);

      // ---------- path ----------
      let path = [];
      let frameIndex = 0;
      const TOUR_SECONDS = 90;
      let tourStartTime = null;

      // ---------- smooth camera variables ----------
      let targetPosition = new THREE.Vector3();
      let currentPosition = new THREE.Vector3();
      let targetLookAt = new THREE.Vector3();
      let currentLookAt = new THREE.Vector3();
      const LERP_FACTOR = 0.05; 

      function applyPose(pos) {
        const [x, y, z] = pos;
        targetPosition.set(x, z, y);
        targetLookAt.set(x, z, y + 1);
      }
      function interpolatePath(path, targetLength) {
        const result = [];
        for (let i = 0; i < targetLength; i++) {
          const t = i / (targetLength - 1) * (path.length - 1);
          const idx = Math.floor(t);
          const frac = t - idx;
          if (idx >= path.length - 1) {
            result.push(path[path.length - 1]);
          } else {
            const p0 = path[idx], p1 = path[idx + 1];
            result.push([
              p0[0] + (p1[0] - p0[0]) * frac,
              p0[1] + (p1[1] - p0[1]) * frac,
              p0[2] + (p1[2] - p0[2]) * frac
            ]);
          }
        }
        return result;
      }

// затем после загрузки path из JSON
path = interpolatePath(path, 1800); // 1800 точек для 60 секунд при 30 FPS


      function initCameraFromFirstPose() {
        if (!path.length) return;
        applyPose(path[0]);
        currentPosition.copy(targetPosition);
        currentLookAt.copy(targetLookAt);
        camera.position.copy(currentPosition);
        camera.up.set(0, -1, 0);
        camera.lookAt(currentLookAt);
      }

      // ---------- Recording ----------
      const STREAM_FPS = 30;
      const RECORD_SECONDS = 90;
      let mediaRecorder = null, recordedChunks = [], recordingStarted = false;

      function startRecording() {
        if (recordingStarted) return;
        recordingStarted = true;

        const stream = renderer.domElement.captureStream(STREAM_FPS);
        mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm" });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) recordedChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "panorama_tour.webm";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          loadingEl.textContent = "Recording finished – video downloaded";
        };

        mediaRecorder.start();
        loadingEl.textContent = "Recording…";

        setTimeout(() => {
          if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
        }, RECORD_SECONDS * 1000);
      }

      // ---------- Load JSON path ----------
      fetch("smooth_panorama_path.json")
        .then(r => r.json())
        .then(data => {
          if (!Array.isArray(data)) throw new Error("smooth_panorama_path.json is not an array");
          path = data.map(p => p.map(v => parseFloat(v)));
          path = interpolatePath(path, RECORD_SECONDS * STREAM_FPS);
          console.log("Loaded path with", path.length, "poses");
          loadingEl.textContent = "Loaded – starting tour";
          if (path.length === 0) { loadingEl.textContent = "Path is EMPTY (0 poses)"; return; }

          initCameraFromFirstPose();
          tourStartTime = performance.now() / 1000;
          setTimeout(() => startRecording(), 500);
        })
        .catch(err => {
          console.error("Failed to load path:", err);
          loadingEl.textContent = "Failed to load path :(";
        });

      // ---------- Resize ----------
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // ---------- Animate ----------
      function animate() {
        requestAnimationFrame(animate);

        if (path.length > 0 && tourStartTime !== null) {
          const now = performance.now() / 1000;
          const elapsed = now - tourStartTime;
          const t = ((elapsed % TOUR_SECONDS) / TOUR_SECONDS);
          const idx = Math.floor(t * path.length) % path.length;
          frameIndex = idx;
          const p = path[idx];

          applyPose(p);

          // плавное движение камеры
          currentPosition.lerp(targetPosition, LERP_FACTOR);
          currentLookAt.lerp(targetLookAt, LERP_FACTOR);

          camera.position.copy(currentPosition);
          camera.up.set(0, -1, 0);
          camera.lookAt(currentLookAt);

          if (idx % 60 === 0) console.log("Pose", idx, "pos=", p);
          setDebug(
            `poses: ${path.length}\nframe: ${idx}/${path.length - 1}\n` +
            `pos: ${p.map(v => v.toFixed(2)).join(", ")}\n` +
            `t: ${t.toFixed(3)}`
          );
        } else {
          setDebug("No path loaded yet…");
        }

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
